# 팰린드롬수

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 128 MB      | 30726 | 17809 | 15745     | 58.417%   |

## 문제

어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.

수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.

## 입력

입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.

## 출력

각 줄마다 주어진 수가 팰린드롬수면 'yes', 아니면 'no'를 출력한다.

## 예제 입력 1

```
121
1231
12421
0
```

## 예제 출력 1

```
yes
no
yes
```

## 회고
round를 써서 하면 쉽게 풀 수 있을 것이라 생각했다.

그런데, round() 함수의 결과가 기대와는 다르게 나오는 경우를 발견했다.

round(1.5), round(2.5)의 결과값을 각각 2, 3으로 기대하고 수행하였다.

결과는 예상과 다르게 2, 2가 나와서 어렸을 때 열심히 배웠던 반올림 공식이 부정당하는 느낌이라 굉장히 현타가 왔었다.

알고보니 python에서는 사사오입 원칙을 따라 반올림할 자리의 수가 5이면,

반올림 할 때 앞자리의 숫자가 짝수면 내림하고 홀수면 올림을 한다는 것을 알았다.

해결 방법은 별도의 반올림함수를 구현하거나, decimal 모듈을 사용해야한다.

그리고 굉장히 어렵게 풀었다.. 반을 쪼개서 하는 것이 아닌 그냥 단어를 reverse해서 같은지 보면 되는데.. 다음부턴 더 단순히 생각해봐야겠다.